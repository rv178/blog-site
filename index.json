[{"content":" Hello! 11 days ago I switched from x11 to wayland, because 60 FPS scrolling is a feature too good to miss.\nNow what is wayland, you may ask? Wayland is like a replacement to the traditional x11 display protocol. You can read more about it here.\nMy x11 setup consisted of the following software:\nDWM as the window manager. Polybar for the status bar. Dunst as the notification daemon. ST as my terminal emulator. Betterlockscreen as the lockscreen. Rofi as the app launcher. Now before switching to wayland, some of these tools listed above straight up break, like betterlockscreen and rofi. ST also behaves weirdly on wayland, but it works. And of course, since DWM is an x11 window manager, you cannot use it on wayland.\nChoosing a compositor Sway was an awesome choice, but I didn\u0026rsquo;t really like the i3-ish aspect of it.\nSo I was looking for something more DWM-like.\nRiver was a great replacement.\nChoosing a bar There are other alternatives like yambar, but I chose waybar.\nNotification daemon While dunst works in wayland, I opted for a notification daemon called mako instead.\nTerminal emulator ST was a great option, but I had to part ways with it. I switched to the foot terminal instead.\nLock screen Since betterlockscreen does not work on wayland, I chose swaylock for the lock screen.\nApplication launcher I use rofi-lbonn-git for the app launcher.\nMy setup You can find my dotfiles here.\nThat\u0026rsquo;s it for this blog see you soon!\n","permalink":"https://rv178.is-a.dev/posts/switching-to-wayland/","summary":"Hello! 11 days ago I switched from x11 to wayland, because 60 FPS scrolling is a feature too good to miss.\nNow what is wayland, you may ask? Wayland is like a replacement to the traditional x11 display protocol. You can read more about it here.\nMy x11 setup consisted of the following software:\nDWM as the window manager. Polybar for the status bar. Dunst as the notification daemon. ST as my terminal emulator.","title":"Switching to Wayland"},{"content":" After using GNU Make for automating the build step in my projects, I had this idea of making my own build automation tool like Make.\nI originally wanted to use Makefile-like syntax for the config file but instead settled with TOML after thinking about it for a while. I also used Rust to write this since I am kinda familiar with the language.\nRust has a TOML crate for parsing TOML files. It also provides support for deserialization and serialization using serde.\nIt\u0026rsquo;s also extremely easy to use:\n// we store custom and pre as HashMap\u0026lt;String, Struct\u0026gt; so that in the TOML file we can use dynamic table names. // for environment variables, it\u0026#39;s stored as HashMap\u0026lt;String, String\u0026gt; so we can specify as many env vars as we like. #[derive(Debug, Deserialize)] struct Recipe { build: Build, custom: Option\u0026lt;HashMap\u0026lt;String, Custom\u0026gt;\u0026gt;, // custom commands pre: Option\u0026lt;HashMap\u0026lt;String, Pre\u0026gt;\u0026gt;, // pre-build commands env: Option\u0026lt;HashMap\u0026lt;String, String\u0026gt;\u0026gt;, // for environment vars } /* \u0026lt;the build, custom and pre structs\u0026gt; */ let recipe: Recipe; match toml::from_str(\u0026amp;recipe_str) { Ok(r) =\u0026gt; recipe = r, Err(e) =\u0026gt; { printb!(\u0026#34;Error: {}\u0026#34;, e); exit(1); } } I didn\u0026rsquo;t include the other structs to make the snippet smaller. This was also the first time I used rust macros in a project, as you can see with the printb! macro. All it does is print Baker: \u0026lt;message\u0026gt; as coloured output.\n#[macro_export] macro_rules! printb { ($($arg:tt)*) =\u0026gt; { println!(\u0026#34;\\x1b[32mBaker:\\x1b[0m {}\u0026#34;, format!($($arg)*)); }; } Configuring baker The configuration file is put in the root directory of the project, just like the Makefile. If Baker is unable to find a config file (called recipe.toml), it auto generates one. For example, I use this config for my chess engine:\n[build] cmd = \u0026#34;cargo build \u0026amp;\u0026amp; cp -r ./target/debug/cranium ./bin/cranium\u0026#34; [custom.clean] cmd = \u0026#34;cargo clean\u0026#34; run = false [custom.setup] cmd = \u0026#34;mkdir -p bin \u0026amp;\u0026amp; rustup install stable \u0026amp;\u0026amp; rustup default stable\u0026#34; run = false [custom.release] name = \u0026#34;release\u0026#34; cmd = \u0026#34;cargo build --release \u0026amp;\u0026amp; cp -r ./target/release/cranium ./bin/cranium\u0026#34; run = false [pre.fmt] cmd = \u0026#34;cargo fmt\u0026#34; Baker is invoked using bake and by default checks for the build field in the recipe.toml. The cmd value is then executed during build.\nYou can also add custom fields using custom. It also checks for a run value that is used to check whether the command should be run after build or not. So if run = true, then the command is run after build.\nBaker also checks for an optional pre field that contains commands which should be run before build. Like for example, if you wish to format your code or something before compiling.\nYou may have noticed a name value in the custom and pre fields ([custom.name]). This is used to identify each field, and for the custom field, the name is set as an argument when Baker is invoked.\nFor example, if I have a custom field called setup:\n[custom.setup] cmd = \u0026#34;mkdir -p bin \u0026amp;\u0026amp; rustup install stable \u0026amp;\u0026amp; rustup default stable\u0026#34; run = false You can run bake setup to directly execute the command inside the field.\nBaker is open source and you can find the repo here. I wrote it in like 2 days, so it may have bugs which I was not able to find, so all suggestions are welcome!\nThat\u0026rsquo;s it for this blog, see you soon!\n","permalink":"https://rv178.is-a.dev/posts/writing-a-build-automation-tool/","summary":"After using GNU Make for automating the build step in my projects, I had this idea of making my own build automation tool like Make.\nI originally wanted to use Makefile-like syntax for the config file but instead settled with TOML after thinking about it for a while. I also used Rust to write this since I am kinda familiar with the language.\nRust has a TOML crate for parsing TOML files.","title":"Writing a Build Automation Tool"},{"content":" I finally finished the FEN string parsing part of my chess engine after days of procrastinating and I just wanted to share my experience with everyone.\nSo a FEN string looks like this:\nrnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1 This is the FEN string of the starting position in standard chess. It looks like random crap at first glance but this string conveys a lot of information.\nSo let\u0026rsquo;s divide it into parts.\nPieces The first part conveys information regarding piece placement. Each letter represents a piece on each rank of the board, and numbers denote empty spaces.\nrnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR Let\u0026rsquo;s look at an example from chess.com here:\nAs you can observe lower case characters are for black pieces and upper case characters are for white pieces.\nNow, moving on to the second part.\nSide to move The second part consists of just a letter which can either be b or w.\nHere we can observe that it\u0026rsquo;s w.\nrnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR | w | KQkq | - | 0 | 1 That means it\u0026rsquo;s white\u0026rsquo;s turn to move, and b means it\u0026rsquo;s black\u0026rsquo;s turn to move.\nCastling ability The third part contains information regarding castling ability of both sides.\nK - White can castle kingside.\nk - Black can castle kingside.\nQ - White can castle queenside.\nq - Black can castle queenside.\nIf no sides can castle, - is used like so:\nrnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w - - 0 1 En passant squares The next part gives us information if any en passant squares are possible. If there are no en passant squares, - is used as demonstrated in this example. If there are any, then the co-ordinates of that square is used.\nHalf move clock and full move counter The next two parts give us information regarding the number of halfmoves and fullmoves completed. Here you can observe the half move count is 0 and the full move count is 1.\nParsing the string To track the current game status, I made a struct called GameStatus.\npub struct GameStatus { pub pieces: Vec\u0026lt;Option\u0026lt;Piece\u0026gt;\u0026gt;, pub side_to_move: Colour, pub castling_id: [bool; 4], pub en_passant: Option\u0026lt;Vec\u0026lt;String\u0026gt;\u0026gt;, pub half_move_clock: u32, pub full_move_count: u32, } What I wanted to do here was make functions for each variable and then assign it to the fields in the struct.\nFor parsing the side to move I first created an enumerator called Colour.\npub enum Colour { White, Black, Undefined, } White and Black are both sides, and undefined is used for error handling if the input is invalid.\nI then created a function that will return a value based on the input given. I really love rust\u0026rsquo;s match syntax ðŸ˜„.\nfn active_side(input: \u0026amp;str) -\u0026gt; Colour { match input { \u0026#34;w\u0026#34; =\u0026gt; Colour::White, \u0026#34;b\u0026#34; =\u0026gt; Colour::Black, _ =\u0026gt; Colour::Undefined, } } if colour == Colour::Undefined { println!(\u0026#34;Invalid FEN string: Failed to parse active colour.\u0026#34;); exit(1); } For parsing castling ability I decided to make an array of bools that would contain values corresponding to the info parsed from the string.\n[true, true, true, true] if input is KQkq (all sides can castle both ways).\nIndex 0 checks if the white king can castle kingside. ie, K and so on.\nIndex 1 =\u0026gt; can white king castle queenside?\nIndex 2 =\u0026gt; can black king castle kingside?\nIndex 3 =\u0026gt; can black king castle queenside?\nSo I made a function that returns this array of bools.\nfn castling_ability(input: \u0026amp;str) -\u0026gt; [bool; 4] { if input == \u0026#34;-\u0026#34; { [false, false, false, false] } else { let mut castling_id = [false; 4]; let mut castling_id_str = input.to_string(); castling_id_str.retain(|c| c != \u0026#39;-\u0026#39;); for c in castling_id_str.chars() { match c { \u0026#39;K\u0026#39; =\u0026gt; castling_id[0] = true, \u0026#39;Q\u0026#39; =\u0026gt; castling_id[1] = true, \u0026#39;k\u0026#39; =\u0026gt; castling_id[2] = true, \u0026#39;q\u0026#39; =\u0026gt; castling_id[3] = true, _ =\u0026gt; { println!(\u0026#34;Invalid FEN string: Failed to parse castling ability.\u0026#34;); exit(1); } } } castling_id } } For parsing en passant squares the solution I came up with was rather stupid.\nSince the input can either be - or multiple squares like e4e5g6 etc., I wanted a vector that contained each square name.\nSo basically,\ne4e5g6 =\u0026gt; [\u0026quot;e4\u0026quot;, \u0026quot;e5\u0026quot;, \u0026quot;g6\u0026quot;]\nfn parse_en_passant_squares(input: \u0026amp;str) -\u0026gt; Vec\u0026lt;String\u0026gt; { let re = Regex::new(r\u0026#34;^-|[a-g]\\d$\u0026#34;).unwrap(); // check if input is valid if re.is_match(input) { let mut char_vec: Vec\u0026lt;String\u0026gt; = Vec::new(); // for storing all characters let mut split_vec: Vec\u0026lt;String\u0026gt; = Vec::new(); // for joining the characters let mut en_passant_vec: Vec\u0026lt;String\u0026gt; = Vec::new(); // our final vec let split_string = input.split(|c: char| c.is_whitespace()); for s in split_string { for c in s.chars() { char_vec.push(c.to_string()); } } for i in 0..char_vec.len() { if i % 2 == 0 { // check if index is divisible by 2 and then push two times split_vec.push(char_vec[i].to_string()); split_vec.push(char_vec[i + 1].to_string()); en_passant_vec.push(split_vec.join(\u0026#34;\u0026#34;)); // join split_vec and push it to our en passant vec split_vec.clear(); // clear split_vec to repeat the process } } en_passant_vec } else { println!(\u0026#34;Invalid FEN string: Failed to parse en passant squares.\u0026#34;); exit(1); } } fn en_passant(input: \u0026amp;str) -\u0026gt; Option\u0026lt;Vec\u0026lt;String\u0026gt;\u0026gt; { if input == \u0026#34;-\u0026#34; { None } else if input.chars().all(char::is_whitespace) { None } else { Some(parse_en_passant_squares(input)) } } I\u0026rsquo;m just an amateur rust developer so there might be 100000 different ways of doing this which are more efficient. For now, it works ðŸ˜‚.\nParsing the halfmove and fullmove counts were rather easy, and I just had to return a u32 from the string input.\nfn halfmove_clock(input: \u0026amp;str) -\u0026gt; u32 { let mut halfmove_clock = String::new(); for c in input.chars() { if c.is_digit(10) { halfmove_clock.push(c); } } halfmove_clock.parse::\u0026lt;u32\u0026gt;().unwrap() } fn fullmove_count(input: \u0026amp;str) -\u0026gt; u32 { let mut fullmove_clock = String::new(); for c in input.chars() { if c.is_digit(10) { fullmove_clock.push(c); } } fullmove_clock.parse::\u0026lt;u32\u0026gt;().unwrap() } However for piece placement parsing, I saw a really good implementation of it in the fen crate so I decided to just joink it ðŸ˜”.\nThere\u0026rsquo;s a struct called Piece that stores the type, colour and symbol (added by me to print out pieces in the board).\npub struct Piece { pub kind: Kind, pub colour: Colour, pub symbol: char, } And an enum Kind:\npub enum Kind { King, Queen, Bishop, Knight, Rook, Pawn, } And according to the input given, a value is returned that is later pushed to a vector.\nlet (color, kind, symbol) = match piece_char { \u0026#39;P\u0026#39; =\u0026gt; (Colour::White, Kind::Pawn, \u0026#39;P\u0026#39;), \u0026#39;N\u0026#39; =\u0026gt; (Colour::White, Kind::Knight, \u0026#39;N\u0026#39;), \u0026#39;B\u0026#39; =\u0026gt; (Colour::White, Kind::Bishop, \u0026#39;B\u0026#39;), \u0026#39;R\u0026#39; =\u0026gt; (Colour::White, Kind::Rook, \u0026#39;R\u0026#39;), \u0026#39;Q\u0026#39; =\u0026gt; (Colour::White, Kind::Queen, \u0026#39;Q\u0026#39;), \u0026#39;K\u0026#39; =\u0026gt; (Colour::White, Kind::King, \u0026#39;K\u0026#39;), \u0026#39;p\u0026#39; =\u0026gt; (Colour::Black, Kind::Pawn, \u0026#39;p\u0026#39;), \u0026#39;n\u0026#39; =\u0026gt; (Colour::Black, Kind::Knight, \u0026#39;n\u0026#39;), \u0026#39;b\u0026#39; =\u0026gt; (Colour::Black, Kind::Bishop, \u0026#39;b\u0026#39;), \u0026#39;r\u0026#39; =\u0026gt; (Colour::Black, Kind::Rook, \u0026#39;r\u0026#39;), \u0026#39;q\u0026#39; =\u0026gt; (Colour::Black, Kind::Queen, \u0026#39;q\u0026#39;), \u0026#39;k\u0026#39; =\u0026gt; (Colour::Black, Kind::King, \u0026#39;k\u0026#39;), _ =\u0026gt; return None, }; You can check out the crate\u0026rsquo;s code for more info.\nI want to write my own implementation too but I\u0026rsquo;m too lazy and it just works.\nI also decided to add this function to print out the game state. Since it\u0026rsquo;s a 1d array I wanted to convert it to a 2d array for printing it.\nSo basically what I did was:\nlet mut symbol_vec: Vec\u0026lt;char\u0026gt; = Vec::new(); // 1d vec that contains piece chars for i in 0..game_state.pieces.len() { if game_state.pieces[i] == None { symbol_vec.push(\u0026#39; \u0026#39;); } else { symbol_vec.push(game_state.pieces[i].as_ref().unwrap().symbol); } } Then I used a function to make a new 2d vector that contains the piece chars.\nfn vec_to_2d_vec(vec: Vec\u0026lt;char\u0026gt;) -\u0026gt; Vec\u0026lt;Vec\u0026lt;char\u0026gt;\u0026gt; { let mut vec_2d: Vec\u0026lt;Vec\u0026lt;char\u0026gt;\u0026gt; = Vec::new(); let mut vec_1d: Vec\u0026lt;char\u0026gt; = Vec::new(); for i in 0..vec.len() { vec_1d.push(vec[i]); if vec_1d.len() == 8 { vec_2d.push(vec_1d); vec_1d = Vec::new(); } } vec_2d } And finally, print it all out.\nlet board = vec_to_2d_vec(symbol_vec); fn print_board(array: \u0026amp;Vec\u0026lt;Vec\u0026lt;char\u0026gt;\u0026gt;) -\u0026gt; String { let mut x = 9; println!(\u0026#34;+---+---+---+---+---+---+---+---+\u0026#34;); let mut buf = String::new(); for (_y, row) in array.iter().enumerate() { for (_x, col) in row.iter().enumerate() { let p_info = format!(\u0026#34;| {} \u0026#34;, col); buf.push_str(\u0026amp;p_info); } x = x - 1; let ranks = format!(\u0026#34;| {} \\n\u0026#34;, x); buf.push_str(\u0026amp;ranks); buf.push_str(\u0026#34;+---+---+---+---+---+---+---+---+\\n\u0026#34;); } buf } print!(\u0026#34;{}\u0026#34;, print_board(\u0026amp;board)); println!(\u0026#34; a b c d e f g h \\n\u0026#34;); Input: rnbqkbnr/pp1ppppp/8/2p5/4P3/5N2/PPPP1PPP/PNBQKB1R b KQkq - 1 2\nOutput:\n+---+---+---+---+---+---+---+---+ | r | n | b | q | k | b | n | r | 8 +---+---+---+---+---+---+---+---+ | p | p | | p | p | p | p | p | 7 +---+---+---+---+---+---+---+---+ | | | | | | | | | 6 +---+---+---+---+---+---+---+---+ | | | p | | | | | | 5 +---+---+---+---+---+---+---+---+ | | | | | P | | | | 4 +---+---+---+---+---+---+---+---+ | | | | | | N | | | 3 +---+---+---+---+---+---+---+---+ | P | P | P | P | | P | P | P | 2 +---+---+---+---+---+---+---+---+ | P | N | B | Q | K | B | | R | 1 +---+---+---+---+---+---+---+---+ a b c d e f g h Anyways that\u0026rsquo;s it for this blog see you soon ðŸ‘‹.\n","permalink":"https://rv178.is-a.dev/posts/fen-string-parsing-in-rust/","summary":"I finally finished the FEN string parsing part of my chess engine after days of procrastinating and I just wanted to share my experience with everyone.\nSo a FEN string looks like this:\nrnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1 This is the FEN string of the starting position in standard chess. It looks like random crap at first glance but this string conveys a lot of information.\nSo let\u0026rsquo;s divide it into parts.","title":"FEN String Parsing in Rust"},{"content":" So a while ago after being absolutely destroyed by a friend in a game of chess, I decided to actually learn the game.\nWhat\u0026rsquo;s chess? Chess is a popular game of strategy where two players play against each other. It involves a chess board containing 64 squares and 16 pieces on each side.\nThe players have a pair of rooks, bishops and knights. They also have eight pawns, a queen and a king. The game is over when you deliver a check (threatening to capture the king of the opposite side) which the enemy king cannot escape.\nGetting better I started by playing games (yeah too obvious) and registering on lichess.org, an amazing open source chess website. Most of these games were against my friends because after playing a rated game I lost horribly to an opponent (got checkmated in like 9 moves).\nAfter playing a few games I decided to check out lichess.org/learn which proved to be a great learning experience.\nChess engines I didn\u0026rsquo;t become a grandmaster after finishing it (unfortunately) so I played more games, particularly against the Stockfish chess engine because my friends wouldn\u0026rsquo;t agree to play with me.\nAround this time I was extremely interested in making a chess engine (inspired by stockfish) and I created a project in Rust, but eventually gave up because it was a lot of work. I had managed to create a board implementation but after trying to implement FEN string parsing I gave up midway.\nHi it\u0026rsquo;s me from the future and I\u0026rsquo;ve decided to rewrite the engine. I got a working FEN string parsing implementation by first splitting the FEN string using whitespaces and then parsing each string individually. It\u0026rsquo;s still not that polished and I aim to refactor it soon and implement game state tracking.\nHowever for the fellow devs who are reading this, chessprogramming.org covers a lot of information regarding engine development in detail.\nStatus Currently I can beat Stockfish Level 4 (1700) on lichess.org and I managed to draw a match with Level 5 (2000).\nI still suck at chess but I hope to become better in the future. It\u0026rsquo;s a very beautiful game and I enjoy playing every match.\n","permalink":"https://rv178.is-a.dev/posts/learning-chess/","summary":"So a while ago after being absolutely destroyed by a friend in a game of chess, I decided to actually learn the game.\nWhat\u0026rsquo;s chess? Chess is a popular game of strategy where two players play against each other. It involves a chess board containing 64 squares and 16 pieces on each side.\nThe players have a pair of rooks, bishops and knights. They also have eight pawns, a queen and a king.","title":"Learning Chess"},{"content":" So hi! I have been using Linux for almost 5 months now and I have learned a lot! Just wanted to share my experience with everyone.\nWhen I asked my friend (who is an expert in Linux), he recommended me Pop!_OS, an Ubuntu based distro. So, I installed it and it was my first Linux distribution. My experience using Pop!_OS was amazing and it still is one of my favourite distributions.\nWhile Linux seemed harder due to the frequent interaction with the command line, I had a bit of experience using it before (when using WSL). So the initial switch wasn\u0026rsquo;t that hard for me. I was still dual booting Windows with Pop!_OS during this time, and was still a Linux amateur.\nThings started to change when I came to know of Arch Linux, a lightweight distribution. I started reading the Arch wiki, and soon installed it on bare metal (after a bit of bullying ahem), triple booting Windows, Pop!_OS and Arch.\nAnd I ABSOLUTELY loved it. I deleted my Pop!_OS partition a while later, and Arch became my primary OS. It was a great way to learn more about Linux and its components. The first desktop environment I used with Arch, was KDE Plasma.\nWhile I certainly liked the desktop environment, I soon switched to a tiling window manager called i3. After using i3 for a few hours, I realised it wasn\u0026rsquo;t the best option for me, and switched back to KDE Plasma. A few days later I installed BSPWM, and I liked it a lot. Inspired from a friend, I installed some of his configs and modified them according to my needs.\nUsing a tiling window manager at first was a bit difficult. But soon, I started relying more on my keyboard than my mouse, switching out code editors like VS code for (Neo)Vim and relying on keyboard shortcuts for my system. Around this time, I had an idea of setting up my dotfiles repo, and I made one. Initially it was just my friend\u0026rsquo;s dotfiles, but modified according to my needs, but soon I started writing my own configs and then published the repo.\nMy BSPWM config now:\nSoon, I switched to DWM and I have been using it ever since. It\u0026rsquo;s my favourite tiling window manager. The level of extensibility it provides is just amazing! Sometimes patching DWM (as well as other suckless utilities) can be a bit tedious though.\n","permalink":"https://rv178.is-a.dev/posts/my-linux-journey/","summary":"So hi! I have been using Linux for almost 5 months now and I have learned a lot! Just wanted to share my experience with everyone.\nWhen I asked my friend (who is an expert in Linux), he recommended me Pop!_OS, an Ubuntu based distro. So, I installed it and it was my first Linux distribution. My experience using Pop!_OS was amazing and it still is one of my favourite distributions.","title":"A brief recap of my Linux journey up until now"}]