<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>FEN String Parsing in Rust | rv178</title><meta name=keywords content="fen,chess,rust"><meta name=description content="I finally finished the FEN string parsing part of my chess engine after days of procrastinating and I just wanted to share my experience with everyone.
So a FEN string looks like this:
rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1 This is the FEN string of the starting position in standard chess. It looks like random crap at first glance but trust me, this string conveys a lot of information."><meta name=author content><link rel=canonical href=https://rv178.is-a.dev/posts/fen-string-parsing-in-rust/><link crossorigin=anonymous href=/assets/css/stylesheet.5e8a76e09692b035be261c6e2e26d6f36eecfb72a71a29af1d7cf4131958efb4.css integrity="sha256-Xop24JaSsDW+JhxuLibW827s+3KnGimvHXz0ExlY77Q=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://media.discordapp.net/attachments/765524394017292309/858181434085867570/1624676782371.png><link rel=icon type=image/png sizes=16x16 href=https://media.discordapp.net/attachments/765524394017292309/858181434085867570/1624676782371.png><link rel=icon type=image/png sizes=32x32 href=https://media.discordapp.net/attachments/765524394017292309/858181434085867570/1624676782371.png><link rel=apple-touch-icon href=https://media.discordapp.net/attachments/765524394017292309/858181434085867570/1624676782371.png><link rel=mask-icon href=https://media.discordapp.net/attachments/765524394017292309/858181434085867570/1624676782371.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="FEN String Parsing in Rust"><meta property="og:description" content="I finally finished the FEN string parsing part of my chess engine after days of procrastinating and I just wanted to share my experience with everyone.
So a FEN string looks like this:
rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1 This is the FEN string of the starting position in standard chess. It looks like random crap at first glance but trust me, this string conveys a lot of information."><meta property="og:type" content="article"><meta property="og:url" content="https://rv178.is-a.dev/posts/fen-string-parsing-in-rust/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-06-29T14:54:23+05:30"><meta property="article:modified_time" content="2022-06-29T14:54:23+05:30"><meta property="og:site_name" content="rv178"><meta name=twitter:card content="summary"><meta name=twitter:title content="FEN String Parsing in Rust"><meta name=twitter:description content="I finally finished the FEN string parsing part of my chess engine after days of procrastinating and I just wanted to share my experience with everyone.
So a FEN string looks like this:
rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1 This is the FEN string of the starting position in standard chess. It looks like random crap at first glance but trust me, this string conveys a lot of information."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://rv178.is-a.dev/posts/"},{"@type":"ListItem","position":3,"name":"FEN String Parsing in Rust","item":"https://rv178.is-a.dev/posts/fen-string-parsing-in-rust/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"FEN String Parsing in Rust","name":"FEN String Parsing in Rust","description":"I finally finished the FEN string parsing part of my chess engine after days of procrastinating and I just wanted to share my experience with everyone.\nSo a FEN string looks like this:\nrnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1 This is the FEN string of the starting position in standard chess. It looks like random crap at first glance but trust me, this string conveys a lot of information.","keywords":["fen","chess","rust"],"articleBody":" I finally finished the FEN string parsing part of my chess engine after days of procrastinating and I just wanted to share my experience with everyone.\nSo a FEN string looks like this:\nrnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1 This is the FEN string of the starting position in standard chess. It looks like random crap at first glance but trust me, this string conveys a lot of information.\nSo letâ€™s divide it into parts.\nPieces The first part conveys information regarding piece placement. Each letter represents a piece on each rank of the board, and numbers denote empty spaces.\nrnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR Letâ€™s look at an example from chess.com here:\nAs you can observe lower case characters are for black pieces and upper case characters are for white pieces.\nNow, moving on to the second part.\nSide to move The second part consists of a just letter which can either be b or w.\nHere we can observe that itâ€™s w.\nrnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR | w | KQkq | - | 0 | 1 That means itâ€™s whiteâ€™s turn to move, and b means itâ€™s blackâ€™s turn to move.\nCastling ability The third part contains information regarding castling ability of both sides.\nK - White can castle kingside.\nk - Black can castle kingside.\nQ - White can castle queenside.\nq - Black can castle queenside.\nIf no sides can castle, - is used like so:\nrnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w - - 0 1 En passant squares The next part gives us information if any en passant squares are possible. If there are no en passant squares, - is used as demonstrated in this example. If there are any, then the co-ordinates of that square is used.\nHalf move clock and full move counter The next two parts give us information regarding the number of halfmoves and fullmoves completed. Here you can observe the half move count is 0 and the full move count is 1.\nParsing the string To track the current game status, I made a struct called GameStatus.\npub struct GameStatus { pub pieces: Vec\u003cOption\u003cPiece\u003e\u003e, pub side_to_move: Colour, pub castling_id: [bool; 4], pub en_passant: Option\u003cVec\u003cString\u003e\u003e, pub half_move_clock: u32, pub full_move_count: u32, } What I wanted to do here was make functions for each variable and then assign it to the fields in the struct.\nFor parsing the side to move I first created an enumerator called Colour.\npub enum Colour { White, Black, Undefined, } White and Black are both sides, and undefined is used for error handling if the input is invalid.\nI then created a function that will return a value based on the input given. I really love rustâ€™s match syntax ðŸ˜„.\nfn active_side(input: \u0026str) -\u003e Colour { match input { \"w\" =\u003e Colour::White, \"b\" =\u003e Colour::Black, _ =\u003e Colour::Undefined, } } if colour == Colour::Undefined { println!(\"Invalid FEN string: Failed to parse active colour.\"); exit(1); } For parsing castling ability I decided to make an array of bools that would contain values corresponding to the info parsed from the string.\n[true, true, true, true] if input is KQkq (all sides can castle both ways).\nIndex 0 checks if the white king can castle kingside. ie, K and so on.\n1 =\u003e can white king castle queenside?\n2 =\u003e can black king castle kingside?\n3 =\u003e can black king castle queenside?\nSo I made a function that returns this array of bools.\nfn castling_ability(input: \u0026str) -\u003e [bool; 4] { if input == \"-\" { [false, false, false, false] } else { let mut castling_id = [false; 4]; let mut castling_id_str = input.to_string(); castling_id_str.retain(|c| c != '-'); for c in castling_id_str.chars() { match c { 'K' =\u003e castling_id[0] = true, 'Q' =\u003e castling_id[1] = true, 'k' =\u003e castling_id[2] = true, 'q' =\u003e castling_id[3] = true, _ =\u003e { println!(\"Invalid FEN string: Failed to parse castling ability.\"); exit(1); } } } castling_id } } For parsing en passant squares the solution I came up with was rather stupid.\nSince the input can either be - or multiple squares like e4e5g6 etc., I wanted a vector that contained each square name.\nSo basically,\ne4e5g6 =\u003e [\"e4\", \"e5\", \"g6\"]\nfn parse_en_passant_squares(input: \u0026str) -\u003e Vec\u003cString\u003e { let re = Regex::new(r\"^-|[a-g]\\d$\").unwrap(); // check if input is valid if re.is_match(input) { let mut char_vec: Vec\u003cString\u003e = Vec::new(); // for storing all characters let mut split_vec: Vec\u003cString\u003e = Vec::new(); // for joining the characters let mut en_passant_vec: Vec\u003cString\u003e = Vec::new(); // our final vec let split_string = input.split(|c: char| c.is_whitespace()); for s in split_string { for c in s.chars() { char_vec.push(c.to_string()); } } for i in 0..char_vec.len() { if i % 2 == 0 { // check if index is divisible by 2 and then push two times split_vec.push(char_vec[i].to_string()); split_vec.push(char_vec[i + 1].to_string()); en_passant_vec.push(split_vec.join(\"\")); // join split_vec and push it to our en passant vec split_vec.clear(); // clear split_vec to repeat the process } } en_passant_vec } else { println!(\"Invalid FEN string: Failed to parse en passant squares.\"); exit(1); } } fn en_passant(input: \u0026str) -\u003e Option\u003cVec\u003cString\u003e\u003e { if input == \"-\" { None } else if input.chars().all(char::is_whitespace) { None } else { Some(parse_en_passant_squares(input)) } } Iâ€™m just an amateur rust developer so there might be 100000 different ways of doing this which are more efficient. For now, it works ðŸ˜‚.\nParsing the halfmove and fullmove counts were rather easy, and I just had to return a u32 from the string input.\nfn halfmove_clock(input: \u0026str) -\u003e u32 { let mut halfmove_clock = String::new(); for c in input.chars() { if c.is_digit(10) { halfmove_clock.push(c); } } halfmove_clock.parse::\u003cu32\u003e().unwrap() } fn fullmove_count(input: \u0026str) -\u003e u32 { let mut fullmove_clock = String::new(); for c in input.chars() { if c.is_digit(10) { fullmove_clock.push(c); } } fullmove_clock.parse::\u003cu32\u003e().unwrap() } However for piece placement parsing, I saw a really good implementation of it in the fen crate so I decided to just joink it ðŸ˜”.\nThereâ€™s a struct called Piece that stores the type, colour and symbol (added by me to print out pieces in the board).\npub struct Piece { pub kind: Kind, pub colour: Colour, pub symbol: char, } And an enum Kind:\npub enum Kind { King, Queen, Bishop, Knight, Rook, Pawn, } And according to the input given, a value is returned that is later pushed to a vector.\nlet (color, kind, symbol) = match piece_char { 'P' =\u003e (Colour::White, Kind::Pawn, 'P'), 'N' =\u003e (Colour::White, Kind::Knight, 'N'), 'B' =\u003e (Colour::White, Kind::Bishop, 'B'), 'R' =\u003e (Colour::White, Kind::Rook, 'R'), 'Q' =\u003e (Colour::White, Kind::Queen, 'Q'), 'K' =\u003e (Colour::White, Kind::King, 'K'), 'p' =\u003e (Colour::Black, Kind::Pawn, 'p'), 'n' =\u003e (Colour::Black, Kind::Knight, 'n'), 'b' =\u003e (Colour::Black, Kind::Bishop, 'b'), 'r' =\u003e (Colour::Black, Kind::Rook, 'r'), 'q' =\u003e (Colour::Black, Kind::Queen, 'q'), 'k' =\u003e (Colour::Black, Kind::King, 'k'), _ =\u003e return None, }; You can check out the crateâ€™s code for more info.\nI want to write my own implementation too but Iâ€™m too lazy and it just works.\nI also decided to add this function to print out the game state. Since itâ€™s a 1d array I wanted to convert it to a 2d array for printing it.\nSo basically what I did was:\nlet mut symbol_vec: Vec\u003cchar\u003e = Vec::new(); // 1d vec that contains piece chars for i in 0..game_state.pieces.len() { if game_state.pieces[i] == None { symbol_vec.push(' '); } else { symbol_vec.push(game_state.pieces[i].as_ref().unwrap().symbol); } } Then I used a function to make a new 2d vector that contains the piece chars.\nfn vec_to_2d_vec(vec: Vec\u003cchar\u003e) -\u003e Vec\u003cVec\u003cchar\u003e\u003e { let mut vec_2d: Vec\u003cVec\u003cchar\u003e\u003e = Vec::new(); let mut vec_1d: Vec\u003cchar\u003e = Vec::new(); for i in 0..vec.len() { vec_1d.push(vec[i]); if vec_1d.len() == 8 { vec_2d.push(vec_1d); vec_1d = Vec::new(); } } vec_2d } And finally, print it all out.\nlet board = vec_to_2d_vec(symbol_vec); fn print_board(array: \u0026Vec\u003cVec\u003cchar\u003e\u003e) -\u003e String { let mut x = 9; println!(\"+---+---+---+---+---+---+---+---+\"); let mut buf = String::new(); for (_y, row) in array.iter().enumerate() { for (_x, col) in row.iter().enumerate() { let p_info = format!(\"| {} \", col); buf.push_str(\u0026p_info); } x = x - 1; let ranks = format!(\"| {} \\n\", x); buf.push_str(\u0026ranks); buf.push_str(\"+---+---+---+---+---+---+---+---+\\n\"); } buf } print!(\"{}\", print_board(\u0026board)); println!(\" a b c d e f g h \\n\"); Input: rnbqkbnr/pp1ppppp/8/2p5/4P3/5N2/PPPP1PPP/PNBQKB1R b KQkq - 1 2\nOutput:\n+---+---+---+---+---+---+---+---+ | r | n | b | q | k | b | n | r | 8 +---+---+---+---+---+---+---+---+ | p | p | | p | p | p | p | p | 7 +---+---+---+---+---+---+---+---+ | | | | | | | | | 6 +---+---+---+---+---+---+---+---+ | | | p | | | | | | 5 +---+---+---+---+---+---+---+---+ | | | | | P | | | | 4 +---+---+---+---+---+---+---+---+ | | | | | | N | | | 3 +---+---+---+---+---+---+---+---+ | P | P | P | P | | P | P | P | 2 +---+---+---+---+---+---+---+---+ | P | N | B | Q | K | B | | R | 1 +---+---+---+---+---+---+---+---+ a b c d e f g h Anyways thatâ€™s it for this blog see you soon ðŸ‘‹.\n","wordCount":"1477","inLanguage":"en","datePublished":"2022-06-29T14:54:23+05:30","dateModified":"2022-06-29T14:54:23+05:30","mainEntityOfPage":{"@type":"WebPage","@id":"https://rv178.is-a.dev/posts/fen-string-parsing-in-rust/"},"publisher":{"@type":"Organization","name":"rv178","logo":{"@type":"ImageObject","url":"https://media.discordapp.net/attachments/765524394017292309/858181434085867570/1624676782371.png"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><ul id=menu><li><a href=https://rv178.is-a.dev/ title=Home><span>Home</span></a></li><li><a href=https://rv178.is-a.dev/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://rv178.is-a.dev/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul><div class=logo><a href=https://rv178.is-a.dev accesskey=h title="  (Alt + H)"></a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://rv178.is-a.dev>Home</a>&nbsp;Â»&nbsp;<a href=https://rv178.is-a.dev/posts/>Posts</a></div><h1 class=post-title>FEN String Parsing in Rust</h1><div class=post-meta><span title='2022-06-29 14:54:23 +0530 +0530'>June 29, 2022</span>&nbsp;Â·&nbsp;7 min&nbsp;Â·&nbsp;1477 words</div></header><div class=post-content><hr><p>I <strong>finally</strong> finished the FEN string parsing part of my chess engine after
days of procrastinating and I just wanted to share my experience with everyone.</p><p>So a FEN string looks like this:</p><pre tabindex=0><code>rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1
</code></pre><p>This is the FEN string of the starting position in standard chess. It looks like random crap at first glance but trust me,
this string conveys a lot of information.</p><p>So let&rsquo;s divide it into parts.</p><h3 id=pieces>Pieces<a hidden class=anchor aria-hidden=true href=#pieces>#</a></h3><p>The first part conveys information regarding piece placement. Each letter represents a piece on each rank of the board, and numbers
denote empty spaces.</p><pre tabindex=0><code>rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR
</code></pre><p>Let&rsquo;s look at an example from chess.com here:</p><p><img loading=lazy src=https://images.chesscomfiles.com/uploads/v1/images_users/tiny_mce/pdrpnht/phpffYq5N.png alt=chess.com-example></p><p>As you can observe lower case characters are for black pieces and upper case characters are for white pieces.</p><p>Now, moving on to the second part.</p><h3 id=side-to-move>Side to move<a hidden class=anchor aria-hidden=true href=#side-to-move>#</a></h3><p>The second part consists of a just letter which can either be <code>b</code> or <code>w</code>.</p><p>Here we can observe that it&rsquo;s <code>w</code>.</p><pre tabindex=0><code>rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR | w | KQkq | - | 0 | 1
</code></pre><p>That means it&rsquo;s white&rsquo;s turn to move, and <code>b</code> means it&rsquo;s black&rsquo;s turn to move.</p><h3 id=castling-ability>Castling ability<a hidden class=anchor aria-hidden=true href=#castling-ability>#</a></h3><p>The third part contains information regarding castling ability of both sides.</p><p><code>K</code> - White can castle <strong>kingside</strong>.</p><p><code>k</code> - Black can castle <strong>kingside</strong>.</p><p><code>Q</code> - White can castle <strong>queenside</strong>.</p><p><code>q</code> - Black can castle <strong>queenside</strong>.</p><p>If no sides can castle, <code>-</code> is used like so:</p><pre tabindex=0><code>rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w - - 0 1
</code></pre><h3 id=en-passant-squares>En passant squares<a hidden class=anchor aria-hidden=true href=#en-passant-squares>#</a></h3><p>The next part gives us information if any en passant squares are possible. If there are no en passant squares, <code>-</code> is used as demonstrated in this example. If there are any, then the co-ordinates of that
square is used.</p><h3 id=half-move-clock-and-full-move-counter>Half move clock and full move counter<a hidden class=anchor aria-hidden=true href=#half-move-clock-and-full-move-counter>#</a></h3><p>The next two parts give us information regarding the number of halfmoves and fullmoves completed. Here you can observe the half move count is <code>0</code>
and the full move count is <code>1</code>.</p><h2 id=parsing-the-string>Parsing the string<a hidden class=anchor aria-hidden=true href=#parsing-the-string>#</a></h2><p>To track the current game status, I made a struct called <code>GameStatus</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>GameStatus</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> pieces: Vec<span style=color:#f92672>&lt;</span>Option<span style=color:#f92672>&lt;</span>Piece<span style=color:#f92672>&gt;&gt;</span>,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> side_to_move: <span style=color:#a6e22e>Colour</span>,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> castling_id: [<span style=color:#66d9ef>bool</span>; <span style=color:#ae81ff>4</span>],
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> en_passant: Option<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;&gt;</span>,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> half_move_clock: <span style=color:#66d9ef>u32</span>,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> full_move_count: <span style=color:#66d9ef>u32</span>,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>What I wanted to do here was make functions for each variable and then assign it to the fields in the struct.</p><p>For parsing the side to move I first created an enumerator called <code>Colour</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>Colour</span> {
</span></span><span style=display:flex><span>    White,
</span></span><span style=display:flex><span>    Black,
</span></span><span style=display:flex><span>    Undefined,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>White and Black are both sides, and undefined is used for error handling if the input is invalid.</p><p>I then created a function that will return a value based on the input given. I really love rust&rsquo;s match syntax ðŸ˜„.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>active_side</span>(input: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>) -&gt; <span style=color:#a6e22e>Colour</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>match</span> input {
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;w&#34;</span> <span style=color:#f92672>=&gt;</span> Colour::White,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;b&#34;</span> <span style=color:#f92672>=&gt;</span> Colour::Black,
</span></span><span style=display:flex><span>        _ <span style=color:#f92672>=&gt;</span> Colour::Undefined,
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>if</span> colour <span style=color:#f92672>==</span> Colour::Undefined {
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;Invalid FEN string: Failed to parse active colour.&#34;</span>);
</span></span><span style=display:flex><span>    exit(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>For parsing castling ability I decided to make an array of bools that would contain values corresponding to the info parsed from
the string.</p><blockquote><p><code>[true, true, true, true]</code> if input is <code>KQkq</code> (all sides can castle both ways).</p></blockquote><p>Index <code>0</code> checks if the white king can castle kingside. ie, <code>K</code> and so on.</p><p><code>1</code> => can white king castle queenside?</p><p><code>2</code> => can black king castle kingside?</p><p><code>3</code> => can black king castle queenside?</p><p>So I made a function that returns this array of bools.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>castling_ability</span>(input: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>) -&gt; [<span style=color:#66d9ef>bool</span>; <span style=color:#ae81ff>4</span>] {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> input <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;-&#34;</span> {
</span></span><span style=display:flex><span>        [<span style=color:#66d9ef>false</span>, <span style=color:#66d9ef>false</span>, <span style=color:#66d9ef>false</span>, <span style=color:#66d9ef>false</span>]
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> castling_id <span style=color:#f92672>=</span> [<span style=color:#66d9ef>false</span>; <span style=color:#ae81ff>4</span>];
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> castling_id_str <span style=color:#f92672>=</span> input.to_string();
</span></span><span style=display:flex><span>        castling_id_str.retain(<span style=color:#f92672>|</span>c<span style=color:#f92672>|</span> c <span style=color:#f92672>!=</span> <span style=color:#e6db74>&#39;-&#39;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> c <span style=color:#66d9ef>in</span> castling_id_str.chars() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>match</span> c {
</span></span><span style=display:flex><span>                <span style=color:#e6db74>&#39;K&#39;</span> <span style=color:#f92672>=&gt;</span> castling_id[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>,
</span></span><span style=display:flex><span>                <span style=color:#e6db74>&#39;Q&#39;</span> <span style=color:#f92672>=&gt;</span> castling_id[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>,
</span></span><span style=display:flex><span>                <span style=color:#e6db74>&#39;k&#39;</span> <span style=color:#f92672>=&gt;</span> castling_id[<span style=color:#ae81ff>2</span>] <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>,
</span></span><span style=display:flex><span>                <span style=color:#e6db74>&#39;q&#39;</span> <span style=color:#f92672>=&gt;</span> castling_id[<span style=color:#ae81ff>3</span>] <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>,
</span></span><span style=display:flex><span>                _ <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                    println!(<span style=color:#e6db74>&#34;Invalid FEN string: Failed to parse castling ability.&#34;</span>);
</span></span><span style=display:flex><span>                    exit(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        castling_id
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>For parsing en passant squares the solution I came up with was rather stupid.</p><p>Since the input can either be <code>-</code> or multiple squares like <code>e4e5g6</code> etc., I wanted a vector that contained each square name.</p><p>So basically,</p><blockquote><p><code>e4e5g6</code> => <code>["e4", "e5", "g6"]</code></p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>parse_en_passant_squares</span>(input: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>) -&gt; Vec<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> re <span style=color:#f92672>=</span> Regex::new(<span style=color:#e6db74>r&#34;^-|[a-g]\d$&#34;</span>).unwrap(); <span style=color:#75715e>// check if input is valid
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> re.is_match(input) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> char_vec: Vec<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> <span style=color:#f92672>=</span> Vec::new(); <span style=color:#75715e>// for storing all characters
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> split_vec: Vec<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> <span style=color:#f92672>=</span> Vec::new(); <span style=color:#75715e>// for joining the characters
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> en_passant_vec: Vec<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> <span style=color:#f92672>=</span> Vec::new(); <span style=color:#75715e>// our final vec
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> split_string <span style=color:#f92672>=</span> input.split(<span style=color:#f92672>|</span>c: <span style=color:#66d9ef>char</span><span style=color:#f92672>|</span> c.is_whitespace());
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> s <span style=color:#66d9ef>in</span> split_string {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> c <span style=color:#66d9ef>in</span> s.chars() {
</span></span><span style=display:flex><span>                char_vec.push(c.to_string());
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> i <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>char_vec.len() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> i <span style=color:#f92672>%</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> { <span style=color:#75715e>// check if index is divisible by 2 and then push two times
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                split_vec.push(char_vec[i].to_string());
</span></span><span style=display:flex><span>                split_vec.push(char_vec[i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>].to_string());
</span></span><span style=display:flex><span>                en_passant_vec.push(split_vec.join(<span style=color:#e6db74>&#34;&#34;</span>)); <span style=color:#75715e>// join split_vec and push it to our en passant vec
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                split_vec.clear(); <span style=color:#75715e>// clear split_vec to repeat the process
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        en_passant_vec
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        println!(<span style=color:#e6db74>&#34;Invalid FEN string: Failed to parse en passant squares.&#34;</span>);
</span></span><span style=display:flex><span>        exit(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>en_passant</span>(input: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>) -&gt; Option<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> input <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;-&#34;</span> {
</span></span><span style=display:flex><span>        None
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> input.chars().all(<span style=color:#66d9ef>char</span>::is_whitespace) {
</span></span><span style=display:flex><span>        None
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        Some(parse_en_passant_squares(input))
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>I&rsquo;m just an amateur rust developer so there might be 100000 different ways of doing this which are more efficient. For now, it works ðŸ˜‚.</p><p>Parsing the halfmove and fullmove counts were rather easy, and I just had to return a u32 from the string input.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>halfmove_clock</span>(input: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>) -&gt; <span style=color:#66d9ef>u32</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> halfmove_clock <span style=color:#f92672>=</span> String::new();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> c <span style=color:#66d9ef>in</span> input.chars() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> c.is_digit(<span style=color:#ae81ff>10</span>) {
</span></span><span style=display:flex><span>            halfmove_clock.push(c);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    halfmove_clock.parse::<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u32</span><span style=color:#f92672>&gt;</span>().unwrap()
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>fullmove_count</span>(input: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>) -&gt; <span style=color:#66d9ef>u32</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> fullmove_clock <span style=color:#f92672>=</span> String::new();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> c <span style=color:#66d9ef>in</span> input.chars() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> c.is_digit(<span style=color:#ae81ff>10</span>) {
</span></span><span style=display:flex><span>            fullmove_clock.push(c);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    fullmove_clock.parse::<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u32</span><span style=color:#f92672>&gt;</span>().unwrap()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>However for piece placement parsing, I saw a really good implementation of it in the <a href=https://lib.rs/crates/fen>fen</a> crate so I decided to just
joink it ðŸ˜”.</p><p>There&rsquo;s a struct called <code>Piece</code> that stores the type, colour and symbol (added by me to print out pieces in the board).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Piece</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> kind: <span style=color:#a6e22e>Kind</span>,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> colour: <span style=color:#a6e22e>Colour</span>,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> symbol: <span style=color:#66d9ef>char</span>,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And an enum <code>Kind</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>Kind</span> {
</span></span><span style=display:flex><span>    King,
</span></span><span style=display:flex><span>    Queen,
</span></span><span style=display:flex><span>    Bishop,
</span></span><span style=display:flex><span>    Knight,
</span></span><span style=display:flex><span>    Rook,
</span></span><span style=display:flex><span>    Pawn,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And according to the input given, a value is returned that is later pushed to a vector.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>let</span> (color, kind, symbol) <span style=color:#f92672>=</span> <span style=color:#66d9ef>match</span> piece_char {
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;P&#39;</span> <span style=color:#f92672>=&gt;</span> (Colour::White, Kind::Pawn, <span style=color:#e6db74>&#39;P&#39;</span>),
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;N&#39;</span> <span style=color:#f92672>=&gt;</span> (Colour::White, Kind::Knight, <span style=color:#e6db74>&#39;N&#39;</span>),
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;B&#39;</span> <span style=color:#f92672>=&gt;</span> (Colour::White, Kind::Bishop, <span style=color:#e6db74>&#39;B&#39;</span>),
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;R&#39;</span> <span style=color:#f92672>=&gt;</span> (Colour::White, Kind::Rook, <span style=color:#e6db74>&#39;R&#39;</span>),
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;Q&#39;</span> <span style=color:#f92672>=&gt;</span> (Colour::White, Kind::Queen, <span style=color:#e6db74>&#39;Q&#39;</span>),
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;K&#39;</span> <span style=color:#f92672>=&gt;</span> (Colour::White, Kind::King, <span style=color:#e6db74>&#39;K&#39;</span>),
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;p&#39;</span> <span style=color:#f92672>=&gt;</span> (Colour::Black, Kind::Pawn, <span style=color:#e6db74>&#39;p&#39;</span>),
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;n&#39;</span> <span style=color:#f92672>=&gt;</span> (Colour::Black, Kind::Knight, <span style=color:#e6db74>&#39;n&#39;</span>),
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#39;b&#39;</span> <span style=color:#f92672>=&gt;</span> (Colour::Black, Kind::Bishop, <span style=color:#e6db74>&#39;b&#39;</span>),
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;r&#39;</span> <span style=color:#f92672>=&gt;</span> (Colour::Black, Kind::Rook, <span style=color:#e6db74>&#39;r&#39;</span>),
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;q&#39;</span> <span style=color:#f92672>=&gt;</span> (Colour::Black, Kind::Queen, <span style=color:#e6db74>&#39;q&#39;</span>),
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#39;k&#39;</span> <span style=color:#f92672>=&gt;</span> (Colour::Black, Kind::King, <span style=color:#e6db74>&#39;k&#39;</span>),
</span></span><span style=display:flex><span>    _ <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>return</span> None,
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>You can check out the crate&rsquo;s code for more info.</p><p>I want to write my own implementation too but I&rsquo;m too lazy and it just works.</p><p>I also decided to add this function to print out the game state. Since it&rsquo;s a 1d array I wanted to convert it to a 2d array for printing it.</p><p>So basically what I did was:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> symbol_vec: Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>=</span> Vec::new(); <span style=color:#75715e>// 1d vec that contains piece chars
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> i <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>game_state.pieces.len() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> game_state.pieces[i] <span style=color:#f92672>==</span> None {
</span></span><span style=display:flex><span>        symbol_vec.push(<span style=color:#e6db74>&#39; &#39;</span>);
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        symbol_vec.push(game_state.pieces[i].as_ref().unwrap().symbol);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Then I used a function to make a new 2d vector that contains the piece chars.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>vec_to_2d_vec</span>(vec: Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span><span style=color:#f92672>&gt;</span>) -&gt; Vec<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span><span style=color:#f92672>&gt;&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> vec_2d: Vec<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span><span style=color:#f92672>&gt;&gt;</span> <span style=color:#f92672>=</span> Vec::new();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> vec_1d: Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>=</span> Vec::new();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>vec.len() {
</span></span><span style=display:flex><span>        vec_1d.push(vec[i]);
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> vec_1d.len() <span style=color:#f92672>==</span> <span style=color:#ae81ff>8</span> {
</span></span><span style=display:flex><span>			vec_2d.push(vec_1d);
</span></span><span style=display:flex><span>			vec_1d <span style=color:#f92672>=</span> Vec::new();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    vec_2d
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And finally, print it all out.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>let</span> board <span style=color:#f92672>=</span> vec_to_2d_vec(symbol_vec);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>print_board</span>(array: <span style=color:#66d9ef>&amp;</span>Vec<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span><span style=color:#f92672>&gt;&gt;</span>) -&gt; String {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> x <span style=color:#f92672>=</span> <span style=color:#ae81ff>9</span>;
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;+---+---+---+---+---+---+---+---+&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> buf <span style=color:#f92672>=</span> String::new();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (_y, row) <span style=color:#66d9ef>in</span> array.iter().enumerate() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (_x, col) <span style=color:#66d9ef>in</span> row.iter().enumerate() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> p_info <span style=color:#f92672>=</span> format!(<span style=color:#e6db74>&#34;| {} &#34;</span>, col);
</span></span><span style=display:flex><span>            buf.push_str(<span style=color:#f92672>&amp;</span>p_info);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        x <span style=color:#f92672>=</span> x <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> ranks <span style=color:#f92672>=</span> format!(<span style=color:#e6db74>&#34;| {} \n&#34;</span>, x);
</span></span><span style=display:flex><span>        buf.push_str(<span style=color:#f92672>&amp;</span>ranks);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        buf.push_str(<span style=color:#e6db74>&#34;+---+---+---+---+---+---+---+---+\n&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    buf
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>print!(<span style=color:#e6db74>&#34;{}&#34;</span>, print_board(<span style=color:#f92672>&amp;</span>board));
</span></span><span style=display:flex><span>println!(<span style=color:#e6db74>&#34;  a   b   c   d   e   f   g   h  \n&#34;</span>);
</span></span></code></pre></div><p>Input: <code>rnbqkbnr/pp1ppppp/8/2p5/4P3/5N2/PPPP1PPP/PNBQKB1R b KQkq - 1 2</code></p><p>Output:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-md data-lang=md><span style=display:flex><span>+---+---+---+---+---+---+---+---+
</span></span><span style=display:flex><span>| r | n | b | q | k | b | n | r | 8
</span></span><span style=display:flex><span>+---+---+---+---+---+---+---+---+
</span></span><span style=display:flex><span>| p | p |   | p | p | p | p | p | 7
</span></span><span style=display:flex><span>+---+---+---+---+---+---+---+---+
</span></span><span style=display:flex><span>|   |   |   |   |   |   |   |   | 6
</span></span><span style=display:flex><span>+---+---+---+---+---+---+---+---+
</span></span><span style=display:flex><span>|   |   | p |   |   |   |   |   | 5
</span></span><span style=display:flex><span>+---+---+---+---+---+---+---+---+
</span></span><span style=display:flex><span>|   |   |   |   | P |   |   |   | 4
</span></span><span style=display:flex><span>+---+---+---+---+---+---+---+---+
</span></span><span style=display:flex><span>|   |   |   |   |   | N |   |   | 3
</span></span><span style=display:flex><span>+---+---+---+---+---+---+---+---+
</span></span><span style=display:flex><span>| P | P | P | P |   | P | P | P | 2
</span></span><span style=display:flex><span>+---+---+---+---+---+---+---+---+
</span></span><span style=display:flex><span>| P | N | B | Q | K | B |   | R | 1
</span></span><span style=display:flex><span>+---+---+---+---+---+---+---+---+
</span></span><span style=display:flex><span>  a   b   c   d   e   f   g   h
</span></span></code></pre></div><p>Anyways that&rsquo;s it for this blog see you soon ðŸ‘‹.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://rv178.is-a.dev/tags/fen/>fen</a></li><li><a href=https://rv178.is-a.dev/tags/chess/>chess</a></li><li><a href=https://rv178.is-a.dev/tags/rust/>rust</a></li></ul><nav class=paginav><a class=next href=https://rv178.is-a.dev/posts/learning-chess/><span class=title>Next Â»</span><br><span>Learning Chess</span></a></nav></footer></article></main><footer class=footer><span>Copyright &copy; 2022 <a href=https://rv178.is-a.dev>rv178</a></span>
<span>| <a href=https://github.com/rv178/blog-site/ rel=noopener target=_blank>Source code</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>